import os
import torch
from torch.utils.data import Dataset, DataLoader
from torchvision import transforms
from PIL import Image
import json
import numpy as np
import pandas as pd 

# --- Constants (should match your data preparation) ---
IMAGE_SIZE = (224, 224)
NUM_NUMERICAL_FEATURES = 47
# Path to the class_to_idx map generated by 1b_prepare_sequential_dataset.py
CLASS_TO_IDX_MAP_PATH = r'/home/avirupd/summer_project/sequential_pose_dataset_seq/class_to_idx.json'
# Paths to class_feature_means.json and stds.json generated by 1_prepare_still_image_dataset.py
CLASS_FEATURE_MEANS_FILE = r'/home/avirupd/summer_project/flat_image_dataset_final/class_feature_means.json'
CLASS_FEATURE_STDS_FILE = r'/home/avirupd/summer_image_dataset_final/class_feature_stds.json'


# --- Helper to load class_to_idx map ---
def load_class_to_idx(map_path):
    if not os.path.exists(map_path):
        raise FileNotFoundError(f"Class to index map not found at {map_path}. Please run prepare_sequential_dataset.py first.")
    with open(map_path, 'r') as f:
        return json.load(f)

# --- Helper to load class_feature_means and stds for imputation/standardization ---
def load_class_feature_stats(means_file_path, stds_file_path):
    means = None
    stds = None
    if os.path.exists(means_file_path):
        with open(means_file_path, 'r') as f:
            means = json.load(f)
    else:
        print(f"Warning: Class feature means file not found at {means_file_path}.")
    
    if os.path.exists(stds_file_path):
        with open(stds_file_path, 'r') as f:
            stds = json.load(f)
    else:
        print(f"Warning: Class feature standard deviations file not found at {stds_file_path}.")
    
    if means is None or stds is None:
        print("WARNING: Numerical feature statistics (means/stds) not fully loaded. Numerical features will not be imputed/standardized.")
        return None, None
    return means, stds

# Load these globally once
CLASS_TO_IDX = load_class_to_idx(CLASS_TO_IDX_MAP_PATH)
IDX_TO_CLASS = {v: k for k, v in CLASS_TO_IDX.items()}
NUM_CLASSES = len(CLASS_TO_IDX)
CLASS_FEATURE_MEANS, CLASS_FEATURE_STDS = load_class_feature_stats(CLASS_FEATURE_MEANS_FILE, CLASS_FEATURE_STDS_FILE)


# --- Existing Dataset for Single Frames (YogaPoseFrameDataset) ---
class YogaPoseFrameDataset(Dataset):
    def __init__(self, data_dir, image_size, is_train=True, transform=None):
        self.data_dir = data_dir
        self.image_size = image_size
        self.is_train = is_train
        self.transform = transform

        self.image_paths = []
        self.numerical_feature_paths = []
        self.labels = []

        self.class_to_idx = CLASS_TO_IDX 
        self.idx_to_class = IDX_TO_CLASS
        self.class_feature_means = CLASS_FEATURE_MEANS
        self.class_feature_stds = CLASS_FEATURE_STDS 

        if self.class_feature_means is None or self.class_feature_stds is None:
            print("WARNING: Class feature means/stds not loaded. Numerical features will not be imputed/standardized.")

        for class_name in os.listdir(data_dir):
            class_path = os.path.join(data_dir, class_name)
            if not os.path.isdir(class_path):
                continue
            
            if class_name not in self.class_to_idx:
                print(f"Warning: Class '{class_name}' found in data directory but not in class_to_idx map. Skipping.")
                continue

            label_id = self.class_to_idx[class_name]

            for filename in os.listdir(class_path):
                if filename.endswith('.jpg'):
                    img_path = os.path.join(class_path, filename)
                    npy_path = os.path.join(class_path, os.path.splitext(filename)[0] + '.npy')
                    
                    if os.path.exists(npy_path):
                        self.image_paths.append(img_path)
                        self.numerical_feature_paths.append(npy_path)
                        self.labels.append(label_id)
                    else:
                        print(f"Warning: Missing .npy file for {filename}. Skipping image.")

        if not self.transform:
            self.transform = transforms.Compose([
                transforms.Resize(self.image_size),
                transforms.ToTensor(),
                transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
            ])

    def __len__(self):
        return len(self.image_paths)

    def __getitem__(self, idx):
        img_path = self.image_paths[idx]
        npy_path = self.numerical_feature_paths[idx]
        label = self.labels[idx]

        image = Image.open(img_path).convert('RGB')
        if self.transform:
            image = self.transform(image)

        numerical_features = torch.from_numpy(np.load(npy_path).astype(np.float32))

        if self.class_feature_means and self.class_feature_stds:
            class_name = self.idx_to_class[label]
            if class_name in self.class_feature_means and class_name in self.class_feature_stds:
                means_for_class = self.class_feature_means[class_name]
                stds_for_class = self.class_feature_stds[class_name]
                
                for i, feature_name in enumerate(means_for_class.keys()): 
                    if torch.isnan(numerical_features[i]):
                        numerical_features[i] = means_for_class[feature_name] 
                    
                    mean_val = means_for_class.get(feature_name, 0.0)
                    std_val = stds_for_class.get(feature_name, 1.0) 
                    
                    if std_val < 1e-6: 
                        numerical_features[i] = 0.0 
                    else:
                        numerical_features[i] = (numerical_features[i] - mean_val) / std_val
            else:
                numerical_features[torch.isnan(numerical_features)] = 0.0
        else:
            numerical_features[torch.isnan(numerical_features)] = 0.0

        return image, numerical_features, label

# --- Dataset for Sequential Data (YogaPoseSequenceDataset) ---
class YogaPoseSequenceDataset(Dataset):
    def __init__(self, data_dir):
        self.data_dir = data_dir
        self.sequence_paths = []
        self.labels = []

        self.class_to_idx = CLASS_TO_IDX 
        self.idx_to_class = IDX_TO_CLASS
        self.class_feature_means = CLASS_FEATURE_MEANS 
        self.class_feature_stds = CLASS_FEATURE_STDS   

        if self.class_feature_means is None or self.class_feature_stds is None:
            print("WARNING: Class feature means/stds not loaded for sequential data. Numerical features will not be imputed/standardized.")

        for class_name in os.listdir(data_dir):
            class_path = os.path.join(data_dir, class_name)
            if not os.path.isdir(class_path):
                continue
            
            if class_name not in self.class_to_idx:
                print(f"Warning: Class '{class_name}' found in sequential data directory but not in class_to_idx map. Skipping.")
                continue

            label_id = self.class_to_idx[class_name]

            for filename in os.listdir(class_path):
                if filename.endswith('.pt'):
                    self.sequence_paths.append(os.path.join(class_path, filename))
                    self.labels.append(label_id) 

    def __len__(self):
        return len(self.sequence_paths)

    def __getitem__(self, idx):
        seq_path = self.sequence_paths[idx]
        label = self.labels[idx]

        data = torch.load(seq_path) 
        
        image_sequence = data['image_sequence'] # (T, C, H, W)
        numerical_sequence = data['numerical_sequence'] # (T, F)
        
        if self.class_feature_means and self.class_feature_stds:
            class_name = self.idx_to_class[label]
            if class_name in self.class_feature_means and class_name in self.class_feature_stds:
                means_for_class = self.class_feature_means[class_name]
                stds_for_class = self.class_feature_stds[class_name]
                
                standardized_numerical_sequence = torch.zeros_like(numerical_sequence)
                for t in range(numerical_sequence.shape[0]): 
                    current_frame_features = numerical_sequence[t]
                    
                    for i, feature_name in enumerate(means_for_class.keys()): 
                        if torch.isnan(current_frame_features[i]):
                            current_frame_features[i] = means_for_class[feature_name] 
                        
                        mean_val = means_for_class.get(feature_name, 0.0)
                        std_val = stds_for_class.get(feature_name, 1.0) 
                        
                        if std_val < 1e-6: 
                            standardized_numerical_sequence[t, i] = 0.0 
                        else:
                            standardized_numerical_sequence[t, i] = (current_frame_features[i] - mean_val) / std_val
                numerical_sequence = standardized_numerical_sequence
            else:
                numerical_sequence[torch.isnan(numerical_sequence)] = 0.0
        else:
            numerical_sequence[torch.isnan(numerical_sequence)] = 0.0

        return image_sequence, numerical_sequence, label

# --- Main get_dataloaders function ---
def get_dataloaders(data_root, batch_size, image_size=IMAGE_SIZE, 
                    num_numerical_features=NUM_NUMERICAL_FEATURES, 
                    mode='fusion', 
                    num_workers=os.cpu_count() // 2 or 1, pin_memory=True):
    """
    Returns DataLoaders for train, validation, and test sets.
    Adjusts dataset type based on the 'mode'.
    """
    
    if mode in ['fusion', 'image_only', 'numerical_only', 'standard_resnet_only']:
        dataset_class = YogaPoseFrameDataset
        train_data_path = os.path.join(data_root, 'train')
        val_data_path = os.path.join(data_root, 'valid')
        test_data_path = os.path.join(data_root, 'test')
        print(f"Using YogaPoseFrameDataset for mode: {mode}")
        
        train_dataset = dataset_class(train_data_path, image_size, is_train=True)
        val_dataset = dataset_class(val_data_path, image_size, is_train=False)
        test_dataset = dataset_class(test_data_path, image_size, is_train=False)

    elif mode in ['quadtree_3d_fusion', 'quadtree_3d_image_only', 'resnet_3d_video_only', 'hybrid_quadtree_3d_fusion', 'hybrid_quadtree_3d_image_only']: # ADDED HYBRID MODES
        dataset_class = YogaPoseSequenceDataset
        # Updated path for augmented sequential dataset
        sequential_data_root = r'/home/avirupd/summer_project/sequential_pose_dataset_seq'
        train_data_path = os.path.join(sequential_data_root, 'train')
        val_data_path = os.path.join(sequential_data_root, 'valid')
        test_data_path = os.path.join(sequential_data_root, 'test')
        print(f"Using YogaPoseSequenceDataset for mode: {mode}")

        train_dataset = dataset_class(train_data_path)
        val_dataset = dataset_class(val_data_path)
        test_dataset = dataset_class(test_data_path)
    else:
        raise ValueError(f"Invalid mode: {mode}. Cannot determine appropriate DataLoader.")

    train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True, num_workers=num_workers, pin_memory=pin_memory)
    val_loader = DataLoader(val_dataset, batch_size=batch_size, shuffle=False, num_workers=num_workers, pin_memory=pin_memory)
    test_loader = DataLoader(test_dataset, batch_size=batch_size, shuffle=False, num_workers=num_workers, pin_memory=pin_memory)

    return train_loader, val_loader, CLASS_TO_IDX, NUM_CLASSES

# Example usage (for testing this file independently)
if __name__ == '__main__':
    print("--- Testing YogaPoseFrameDataset (single-frame) ---")
    data_root_2d = r'/home/avirupd/summer_project/flat_image_dataset_final' 
    train_loader_2d, val_loader_2d, class_to_idx_2d, num_classes_2d = get_dataloaders(
        data_root=data_root_2d, 
        batch_size=4, 
        mode='fusion' 
    )
    print(f"2D Train Loader has {len(train_loader_2d.dataset)} samples.")
    for images, numerical_features, labels in train_loader_2d:
        print(f"2D Batch images shape: {images.shape}") 
        print(f"2D Batch numerical features shape: {numerical_features.shape}") 
        print(f"2D Batch numerical features (first sample, first 5 features): {numerical_features[0, :5]}")
        print(f"2D Batch numerical features (first sample, min/max): {numerical_features[0].min():.4f}, {numerical_features[0].max():.4f}")
        break

    print("\n--- Testing YogaPoseSequenceDataset (sequential) ---")
    train_loader_3d, val_loader_3d, class_to_idx_3d, num_classes_3d = get_dataloaders(
        data_root='dummy_path', 
        batch_size=2, 
        mode='quadtree_3d_fusion' 
    )
    print(f"3D Train Loader has {len(train_loader_3d.dataset)} samples.")
    for image_sequences, numerical_sequences, labels in train_loader_3d:
        print(f"3D Batch image sequences shape: {image_sequences.shape}") 
        print(f"3D Batch numerical sequences shape: {numerical_sequences.shape}") 
        print(f"3D Batch numerical sequences (first sample, first frame, first 5 features): {numerical_sequences[0, 0, :5]}")
        print(f"3D Batch numerical sequences (first sample, first frame, min/max): {numerical_sequences[0, 0].min():.4f}, {numerical_sequences[0, 0].max():.4f}")
        break
